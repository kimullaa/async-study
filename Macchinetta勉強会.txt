# Macchinetta勉強会

## テーマ
- 非同期処理のパターンと使いどころの整理(議論ベース)
- Springにおける実装方法(コードレビュー)

## 非同期処理のパターン
非同期とは「あるタスクをしている間に別のタスクを実行できること」
言葉の定義が広いので、大小さまざまな非同期パターンが存在する。

### 非同期にする動機
- 処理負荷が高いため
- 処理時間が長いため
- まとめて実行する必要があるため

### 基本的な指針
処理負荷が高いものはWEBサーバとは別プロセスや別サーバに分けるべき
 - WEBシステムは軽い処理を大量にさばくことに向いてるアーキテクチャ。
   (リクエスト単位でふりわけることが多いので、処理負荷を均等にできない)
 - 処理負荷は高くないが時間のかかる処理(他システムAPIのコールなど)
   はWEBサーバ上で実行すればよい。

### ユーザから見たときのふるまいで分類する
1. リアルタイムに処理結果を通知するパターン
2. 受付だけ済ませていつか終わればよいパターン
3. パフォーマンス向上を目的としたパターン(ユーザからは同期と変わらない)

### リアルタイムに処理結果を更新するパターン
#### 実現方法
クライアントへの通知手段(サーバPUSH)
  - polling(クライアントでapiを定期的にコールする)
  - comet(ResponseBodyEmitter,AsyncContext(Servlet標準))
  - SSE(ResponseBodyEmitter, SseEmitter)
  - websocket(Stomp)
処理手段
  - WEBサーバで実行(worker用スレッド生成、@Asyncで別スレッド起動)
  - 別プロセスで実行
    - DBから起動(Macchinetta 非同期バッチ)
    - Processをコール
#### 比較
NWトラフィック、実装難易度、標準技術？、サーバ負荷


### 受付だけ済ませていつか終わればよいパターン
実行タイミングが未定な処理はこのパターン。

#### 実現方法
- JMS(Spring JMS , JMS)
- 簡易的なQueueの独自実装(@Async + TaskExecutor)
- Macchinetta 非同期バッチ
#### 比較
上限制御、再送制御、配信制御
#### 注意点
運用考慮事項が増える。
リアルタイム処理なら客にエラー画面出してリトライさせられるけど、
いったん受け付けた後のエラーはどう返す？★非同期で話したほうがいいところ
 - ミスったリクエストがキューにたまったときに消せる？消すのは運用対処？
 - 実行ミスったらゴミキューにつっこんどいて後で運用対処


### ユーザからは同期と変わらず、パフォーマンス向上のために取るパターン
#### 実現方法
- Callable,DeferredResult,Future
- @Async + Future
#### どんなときにやりたくなる？
xxx
#### 比較

## 実装ポイント
@Asyncで例外ハンドリングはどうすべき?

## 参考
サーバPUSH<http://www.slideshare.net/mawarimichi/push-37869433>
