# Macchinetta勉強会

## テーマ
- 非同期処理のパターンと使いどころの整理(議論ベース)
- Springにおける実装方法(コードレビュー)

## 非同期処理のパターン
非同期とは「あるタスクをしている間に別のタスクを実行できること」
言葉の定義が広いので、大小さまざまな非同期パターンが存在する。

### ユーザから見たときのふるまいで分類する
- リアルタイムに処理結果を通知するパターン(サーバPUSH)
- 受付だけして後でいつか終わればよいパターン
- パフォーマンス向上を目的としたパターン(ユーザからは同期と変わらない)


### リアルタイムに処理結果を更新できるパターン(サーバPUSH)
- ファイルアップロードなどの一括更新処理など、非常に重たくてAPサーバの負荷がかかる処理で実施する。
  WEBサーバとは別プロセス・別サーバに分けるべき-> 負荷分散が難しい
  DB等に更新させて通知方法としてpollingやcometやSSEを使う。
- 他システムへのAPI呼び出しなど、処理は重たくないけど時間がかかるようなものは
  comet,SSEなどが使える？
#### 実現方法
- polling(@Asyncで別スレッドを実行し、DBレコードを更新。別のリクエストでDBレコードを表示してポーリング。)
- comet(ResponseBodyEmitter,AsyncContext(Servlet標準))
- SSE(ResponseBodyEmitter, SseEmitter)
- websocket(Stomp)
- バッチ起動
#### 比較
NWトラフィック、実装難易度、標準技術？、サーバ負荷


### リアルタイムに処理結果を更新せず、後でいつか終わればよいパターン
#### 実現方法
- JMS(Spring JMS , JMS)
- 簡易的なQueueの独自実装(@Async + TaskExecutor)
- Macchinetta 非同期バッチ機能
#### どんなときにやりたくなる？
実行タイミングが未定。
#### 比較
上限制御、再送制御、配信制御
#### 注意点
運用考慮事項が増える。
リアルタイム処理なら客にエラー画面出してリトライさせられるけど、
いったん受け付けた後のエラーはどう返す？★非同期で話したほうがいいところ
 - ミスったリクエストがキューにたまったときに消せる？消すのは運用対処？
 - 実行ミスったらゴミキューにつっこんどいて後で運用対処


### ユーザからは同期と変わらず、パフォーマンス向上のために取るパターン
#### 実現方法
- Callable,DeferredResult,Future
- @Async + Future
#### どんなときにやりたくなる？
xxx
#### 比較

## 実装ポイント
@Asyncで例外ハンドリングはどうすべき?

## 参考
サーバPUSH<http://www.slideshare.net/mawarimichi/push-37869433>
