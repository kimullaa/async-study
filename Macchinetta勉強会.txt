# Macchinetta勉強会

## テーマ
- 非同期処理のパターンと使いどころの整理(議論ベース)
- Springにおける実装方法(コードレビュー)


## 非同期処理のパターンと使いどころの整理(議論ベース)


### 非同期処理とは
非同期とは「あるタスクをしている間に別のタスクを実行できること」
言葉の定義が広いので、大小さまざまな非同期パターンが存在する。


### 非同期にする動機
- 処理負荷が高いため
- 処理時間が長いため
- 今すぐには実行できないため
 (対向システムのデータを待ってからじゃないと駄目とか)


### 基本的な指針
- 処理負荷が高いものはWEBサーバとは別プロセスや別サーバに分けるべき
  WEBシステムは軽い処理を大量にさばくことに向いてるアーキテクチャ。
  リクエスト単位でふりわけることが多いので、処理負荷を均等にできない。
- 処理負荷は高くないが時間のかかる処理(他システムAPIのコールなど)
  はWEBサーバ上で実行すればよい。


### 処理手段
- WEBサーバで実行(worker用スレッド生成、@Asyncで別スレッド起動)
- 別プロセスで実行
  - JMS
  - DB契機でバッチ起動(Macchinetta 非同期バッチ)
  - Processをコール(地獄のはじまり)


### 処理手段の比較
再送制御、配信制御、同時実行数の制御は必要か?


### 通知手段
リアルタイムに通知
  - polling(クライアントでapiを定期的にコールする)
  - comet(ResponseBodyEmitter,AsyncContext(Servlet標準))
  - SSE(ResponseBodyEmitter, SseEmitter)
  - websocket(Stomp)

あとで通知
  - メール
  - タスク確認画面を提供する


### 注意点
TODO:
運用考慮事項が増える。
リアルタイム処理なら客にエラー画面出してリトライさせられる。
いったん受け付けた後の実行エラーはどう返す？
 - ミスったリクエストがキューにたまったときに消せる？消すのは運用対処？
 - 実行ミスったらゴミキューにつっこんどいて後で運用対処?


### パフォーマンス向上のための非同期処理
ユーザから見れば同期リクエストと変わらないが、
workerスレッドを節約するために重たい処理を別スレッドで実行する。
  - Callable,DeferredResult,Future
  - @Async + Future


### 参考
サーバPUSH<http://www.slideshare.net/mawarimichi/push-37869433>


### Springにおける実装方法(コードレビュー)
- @Asyncで例外ハンドリングはどうすべき?
